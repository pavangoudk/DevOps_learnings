# OSI Model Deep Dive: DNS, TCP Handshake, and Data’s 7-Layer Journey

## Quick recap of Episode 1 (as stated)

# 

- Episode 1 covered:
- IP address
- subnet + types of subnets
- CIDR (how to read/write and calculate CIDR blocks)
- Speaker recommends watching Episode 1 if these basics aren’t familiar.

## Why OSI model matters (setup example: google.com)

# 
- Everyday scenario: open a browser and search **google.com** → response comes back in fractions of a second (Google homepage / HTML).
- Core question: how does the request travel from laptop → internet → Google servers, and how does the response return?
- OSI model helps explain the *“journey of data across the internet”* and breaks it into **seven layers** (Layer 7 to Layer 1, or Layer 1 to Layer 7 at the receiving end).

## Two prerequisites before OSI model “comes into picture”

# 
- Before the browser initiates the request journey, two steps happen:
1. DNS resolution
2. TCP handshake

### DNS Resolution (Domain Naming Service)

# 
- *“There is a system called DNS which is nothing but domain naming service… understand it as a simple database… where records are maintained.”*
- What’s being checked:
- whether `www.google.com` maps to an IP address.
- How the lookup happens (sequence described):
1. Router checks **local cache** (if it has visited before, the mapping might be stored).
2. If not found locally, it queries the **Internet Service Provider (ISP)** DNS (speaker: ISPs maintain DNS with records).
- Example mapping stated: google.com is mapped to **8.8.8.8** (as given in the transcript).
- Why DNS resolution happens first:
- If the domain doesn’t exist (speaker example: `www.abishekvera.com`), there’s no point starting the “data journey,” especially if you might send large data (e.g., 10 GB).

### TCP Handshake (Three-way handshake)

# 
- Purpose framing: before sending, confirm the server is ready to accept.
- *Handshake = “trying to say hi and it says hi I’m okay to accept your request.”*
- Steps (networking terms used):
1. Client sends **SYN**
2. Server responds **SYN-ACK**
3. Client responds **ACK**
- Speaker notes:
- Doesn’t deep-dive into why not 2-step.
- Mentions there are also **two-way** and **four-way** handshakes, but **three-way** is the most popular and mostly used.

## OSI Model: what happens after DNS + TCP succeed

# 
- Assumption: DNS resolution successful + TCP handshake successful.
- Then the request initiation begins through OSI layers.

### Application example used throughout

# 
- Requesting: `https://www.google.com`

## Layer-by-layer flow (Laptop → Server): Layer 7 to Layer 1

## Layer 7: Application Layer

# 

- *Browser initiates an HTTP/HTTPS request to the server.*
- *“This particular stage is called… layer 7… also called as application layer.”*
- Speaker notes:
- You can pass **headers**
- You can include **authentication information** as needed
- If you requested something else (example given): FTP → browser initiates an FTP-based request.

## Layer 6: Presentation Layer

# 
- After HTTP request initiation, next step: encryption / formatting.
- *“Data encryption… also called as data formatting… layer six… presentation layer.”*
- Motivation: data passes multiple routers; encryption helps if someone intercepts traffic (ties to using **HTTPS**).

## Layer 5: Session Layer

# 
- Next step: create a session between client and server.
- Definition-by-example:
- Facebook scenario:
- Log in once for `facebook.com/abisheka`
- 20 minutes later open another tab/window and go to a different profile path
- You aren’t asked to authenticate again because a **session** is maintained.
- Banking scenario:
- You shouldn’t be forced to log in repeatedly mid-transactions unless you log out.
- Speaker adds:
- Sessions are stored in **cookies and cache** (as stated).
- Clearing cookies/cache forces re-authentication.
- Key point: Layers **7/6/5 are handled by the browser** (Chrome/Firefox/etc.).
- Up to here, the request “did not reach” the router yet (speaker’s emphasis).

## Layer 4: Transport Layer

# 
- Two main activities described:
1. **Segmentation**: data is split into parts (especially relevant for large data like 10 GB, but also applies generally).
2. **Protocol selection**: choose **TCP or UDP**
- Layer name: *“this layer is called as transport layer.”*
- Protocol mapping examples stated:
- HTTP → typically **TCP**
- DNS → typically **UDP**
- Result: segmented data is transmitted using the chosen protocol (e.g., TCP for HTTP).

## Layer 3: Network Layer (speaker calls it “networking layer”)

# 
- Data reaches the **router**.
- Router responsibilities (two ideas via analogy):
- Know destination (Delhi → Mumbai analogy)
- Choose shortest/fastest path among many routes (multiple hops/routers)
- What gets added:
- **Source IP address** and **Destination IP address** to each segment.
- Naming change:
- Once IP info is added, data is called **packets**.
- Routing decisions:
- Router decides which hops/routers packets should traverse.

## Layer 2: Data Link Layer

# 
- Transition described: routers connect to **switches / ethernet**.
- Medium change drives representation change:
- Packets (router context) → **frames** (switch context)
- What gets added in frames:
- **MAC information / MAC address** (to help switches understand components within the network).
- Layer name: *“this layer is called as data link layer.”*

## Layer 1: Physical Layer

# 
- End-to-end physical medium described: switches/routers connect to **optical cables**.
- Data is converted to **electronic signals** for transmission over cables.
- Layer name: *“layer one… physical layer.”*

## End-to-end summary (send vs receive direction)

# 
- Sending (client side): data flows **Layer 7 → 1**.
- Across the internet: multiple hops (cable → router → switch → cable …) until it reaches Google servers.
- Receiving (server side): OSI processing happens in reverse **Layer 1 → 7**:
- Physical reception (cable) → switches → routing → transport (TCP/UDP handling) → session validation → decryption → application processes request
- Google application (microservice/monolith, as stated) generates an HTML response
- Response returns back to the laptop through the reverse path (again Layer 1 → 7 on the client receive side).

## OSI model vs TCP/IP model (as explained)

# 
- OSI model: 7-layer explanatory standard.
- TCP/IP model: based on OSI.
- In TCP/IP model, **Layer 7 + 6 + 5** are combined into a single layer because they’re largely handled by the same component (the browser).
- Why learn OSI:
- It’s a standard and helps understand overall transmission; other/newer models are based on it.

## Practical relevance for DevOps (speaker’s framing)

# 
- OSI knowledge is *“good to have,”* not strictly must-have.
- Reason: much is standardized and automated today.
- Tool mention:
- People don’t commonly use tools like **Wireshark** unless working in core networking / focusing on Layer 2/3.
- Recommendation: a high-level OSI understanding is enough for DevOps; deep protocol specifics can be “an ocean.”
